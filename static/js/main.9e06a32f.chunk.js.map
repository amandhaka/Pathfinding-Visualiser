{"version":3,"sources":["PathFinder/Pathfinder.module.css","icons/cover.png","PathFinder/PopUp.jsx","PathFinder/Node.jsx","Algorithms/Dijsktra.js","Algorithms/DFS.js","Algorithms/Astar.js","MazeAlgorithm/dfsmaze.js","MazeAlgorithm/RecursiveDivision.js","MazeAlgorithm/kruskal.js","Algorithms/BiBfs.js","PathFinder/Pathfinder.jsx","Algorithms/BFS.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","PopUp","useState","open","setOpen","handleClose","Dialog","className","onClose","scroll","aria-labelledby","aria-describedby","DialogTitle","id","DialogContent","dividers","style","fontFamily","color","DialogActions","Button","onClick","Node","row","col","onMouseDown","onMouseUp","onMouseEnter","isStart","isFinish","isWall","onMouseClick","extraClass","dijsktra","grid","startNode","finishNode","visitedNodes","distance","unVisitedNodes","node","push","getAllNodes","length","sortByDistance","closestNode","shift","Infinity","isVisited","updateNeighbours","sort","nodeA","nodeB","neighbors","filter","neighbor","getAllNeighbors","previousNode","helper","currentNode","previous","getAllNode","nodes","g","f","h","calculateGFH","heuristicManhattanDistance","Math","abs","unvisitedNodes","stackChild","dfsMazeRecursive","x","y","array","i","j","floor","random","sideNodesX1","sideNodesY1","sideNodesX2","sideNodesY2","k","newX2","newY2","newX1","newY1","childNode","pop","recursiveDivision","height","width","tempNode","tempNode1","recursiveDivisionMaze","startX","endX","startY","endY","hOrV","getOrientation","wallX","getRandomInt","skipY","wallY","skipX","min","max","addNewProperty","isNeighborVisited","ROWS","window","innerHeight","COLS","innerWidth","toggleVisitedAfterMaze","walls","newGrid","slice","newNode","getNewGridwithStartNode","getNewGridWithEndNode","getNewGridWithWall","PathFinder","setGrid","mouseIsPressed","setMousePress","setStartNode","endNode","setEndNode","startRow","setStartRow","startCol","setStartCol","finishRow","setFinishRow","finishCol","setFinishCol","disableButtons","setDisableButtons","useEffect","getIntialGrid","visualise","clearBoard","previousBoard","maze","createNode","currentRow","findDfs","dfs","nodesInShortestPath","unshift","getShortestPath","animatePath","setTimeout","disableButton1","findAstar","astar","shortestPath","getNodesInShortestPathAstar","bidirectionalBFS","visitedNodes1","visitedNodes2","q1","q2","fromStart","fromEnd","includes","nextNode","biBfs","midNodeFromStart","midNodeFromEnd","getNodesInShortestPathBiBfs","dfsRecursiveMaze","dfsMaze","document","getElementById","kruskalMaze","console","log","idx","neighborNode","neighborNode1","tempIdx","indexOf","splice","kruskal","animateShortestPath","visualizeAlgorithm","algorithm","disableButton","getNodesInShortestPathOrder","findDijkstraPath","queue","bfs","shortestPathNodes","getNodesInShortestPath","findBfs","alert","visualizeMaze","recursiveMaze","setAlgorithm","setMaze","container","nav","src","cover","alt","image","FormControl","variant","centered","formControl","InputLabel","Typography","labelText","align","display","Select","value","onChange","e","target","labelId","MenuItem","button","disabled","buttonText","getPreviousBoard","map","rowIdx","key","nodeIdx","setStartAndEndNode","handleMouseDown","handleMouseEnter","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.9e06a32f.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"grid\":\"Pathfinder_grid__2jH6f\",\"nav\":\"Pathfinder_nav__3BIz2\",\"formControl\":\"Pathfinder_formControl__32cwM\",\"button\":\"Pathfinder_button__jaba0\",\"buttonText\":\"Pathfinder_buttonText__2nROk\",\"image\":\"Pathfinder_image__3f-xu\",\"button-group\":\"Pathfinder_button-group__1KGUh\",\"labelText\":\"Pathfinder_labelText__3teSc\"};","module.exports = __webpack_public_path__ + \"static/media/cover.a06cfb85.png\";","import React,{useState} from 'react';\r\nimport {Button,Dialog,DialogActions,DialogContent,DialogTitle} from '@material-ui/core';\r\nimport \"./PopUp.css\";\r\nconst PopUp=()=>{\r\n    const [open,setOpen]=useState(true);\r\n    const handleClose=()=>{\r\n        setOpen(false);\r\n    }\r\n    return(\r\n        <div>\r\n            <Dialog\r\n            className=\"dialog\"\r\n            open={open}\r\n            onClose={handleClose}\r\n            scroll='paper'\r\n            aria-labelledby=\"scroll-dialog-title\"\r\n            aria-describedby=\"scroll-dialog-description\"\r\n            >\r\n                <DialogTitle id=\"scroll-dialog-title\"><div className=\"title\"></div></DialogTitle> \r\n                <DialogContent dividers>\r\n                    <div id=\"scroll-dialog-description\" style={{fontFamily:\"'Rajdhani', sans-serif\",color:\"#002244\"}}>\r\n                            You must've heard of many Pathfinding Algorithms but Do you know how some of them work?\r\n                            Here, you can visualise how some famous pathfinding algorithms works and finds the path from <i>Source</i> to <i>Destination</i>.\r\n                            <br></br>\r\n                            <br></br>\r\n                            <h5>Implmented Pathfinding Algorithms</h5>\r\n                            <ul>\r\n                                <li style={{color:\"#d92027\"}}>A* Search</li>\r\n                                <li style={{color:\"#d92027\"}}>Dijkstra's Search</li>\r\n                                <li style={{color:\"#d92027\"}}>Breadth First Search</li>\r\n                                <li style={{color:\"#d92027\"}}>Bi-directional Breadth First Search</li>\r\n                                <li style={{color:\"#d92027\"}}>Depth First Search</li>\r\n                            </ul>\r\n                            You can also add some walls to block the path from Source to Destination and there is an option to generate different types of mazes on the board.\r\n                            <br/><strong><i>Don't skip the Instructions part after this line. It can be a bit tricky to use it for first time</i></strong>\r\n                            <br></br>\r\n                            <br></br>\r\n                            <h2>Instructions</h2><hr></hr>\r\n                            <ul>\r\n                                <li>The first time you click on any cell, it will be marked as <code>Source</code>.</li>\r\n                                <li>The second click on any cell will mark it as <code>Destination</code>.</li>\r\n                                <li>After marking Source and Destination, you can make walls by pressing the mouse button on any cell and then dragging it to other cells.</li>\r\n                                <li>Once you are done with creating souce, destination and walls then choose the pathfinding algorithm from the top left dropdown list.</li>\r\n                                <li>Click on the <strong>Visualize</strong><i> algorithm-name </i> to start the pathfinding process so that you can see how that works.</li>\r\n                                <li>You can also generate mazes by selecting any maze from dropdown list on top right corner and then click on <strong>Generate Maze </strong>button.</li>\r\n                                <li>Don't mark your source and destination before the maze is generated if you are planning to generate maze.</li>\r\n                                <li>If you want to remove everything from board except Source and Destination then click on <strong>Previous Board </strong>button.</li>\r\n                                <li>If want to reset the board to initial state then just click on <strong>Clear Board</strong> button.</li>\r\n                            </ul>\r\n                            <strong><i>All the cells in blue color are visited cells by the source and the path which source takes is shown by cells colored in Green color.</i></strong>\r\n                    </div>\r\n                </DialogContent>\r\n                <DialogActions>\r\n                    <Button onClick={handleClose} color=\"secondary\">Close</Button>\r\n                </DialogActions>    \r\n            </Dialog>\r\n        </div>\r\n    )\r\n}\r\nexport default PopUp;","import React from 'react';\r\nimport './Node.css';\r\nconst Node = ({row,col,onMouseDown,onMouseUp,onMouseEnter,isStart,isFinish,isWall,onMouseClick}) => {\r\n    const extraClass=isFinish?\r\n    'node-finish': isStart?\r\n    'node-start':isWall?\r\n    'node-wall':'';\r\n    return ( \r\n    <div\r\n    className={`node ${extraClass}`}\r\n    id={`node-${row}-${col}`}\r\n    onClick={()=>onMouseClick(row,col)}\r\n    onMouseDown={()=>onMouseDown(row,col)}\r\n    onMouseEnter={()=>onMouseEnter(row,col)}\r\n    onMouseUp={()=>onMouseUp()}\r\n    ></div>\r\n    );\r\n}\r\n \r\nexport default Node;","export function dijsktra(grid,startNode,finishNode){\r\n  const visitedNodes=[];\r\n    startNode.distance=0;\r\n    const unVisitedNodes=getAllNodes(grid);\r\n    //console.log(startNode);\r\n    while(!!unVisitedNodes.length){\r\n        sortByDistance(unVisitedNodes);\r\n        const closestNode=unVisitedNodes.shift();\r\n        if(closestNode.isWall===true) continue;\r\n        if(closestNode.distance===Infinity) return visitedNodes;\r\n        closestNode.isVisited=true;\r\n        visitedNodes.push(closestNode);\r\n        if(closestNode===finishNode) return visitedNodes;\r\n        updateNeighbours(closestNode,grid);\r\n    }\r\n   // console.log(\"HERERER\");\r\n}\r\nfunction sortByDistance(unVisitedNodes){\r\n    unVisitedNodes.sort((nodeA,nodeB)=>nodeA.distance-nodeB.distance);\r\n}\r\nfunction updateNeighbours(closestNode,grid){\r\n    const neighbors=getAllNeighbors(closestNode,grid);\r\n    for(const neighbor of neighbors){\r\n      neighbor.distance=closestNode.distance+1;\r\n      neighbor.previousNode=closestNode;\r\n    }\r\n}\r\nfunction getAllNeighbors(closestNode,grid){\r\n    const neighbors=[];\r\n    const{row,col}=closestNode;\r\n    if(row>0) neighbors.push(grid[row-1][col]);\r\n    if(row<grid.length-1) neighbors.push(grid[row+1][col]);\r\n    if(col>0) neighbors.push(grid[row][col-1]);\r\n    if(col<grid[0].length-1) neighbors.push(grid[row][col+1]);\r\n    return neighbors.filter((neighbor)=>!neighbor.isVisited)\r\n}\r\nfunction getAllNodes(grid){\r\n    const unVisitedNodes=[];\r\n    for(const row of grid){\r\n      for(const node of row){\r\n          unVisitedNodes.push(node);\r\n      }\r\n    }\r\n    return unVisitedNodes;\r\n}\r\nexport function getNodesInShortestPathOrder(finishNode){\r\n    const nodesInShortestPath=[];\r\n    let currentNode=finishNode;\r\n    while(currentNode!==null){\r\n      nodesInShortestPath.unshift(currentNode);\r\n      currentNode=currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPath;\r\n}","export const dfs=(grid,startNode,finishNode)=>{\r\n    const visitedNodes=[];\r\n    const unVisitedNodes=getAllNode(grid);\r\n    startNode.distance=0;\r\n    helper(visitedNodes,unVisitedNodes,grid,startNode,finishNode,null);\r\n    return visitedNodes;\r\n}\r\nconst helper=(visitedNodes,unVisitedNodes,grid,currentNode,finishNode,previous)=>{\r\n    if(finishNode.isVisited) return;\r\n    if(currentNode===finishNode){\r\n        finishNode.previousNode=previous;\r\n        finishNode.isVisited=true;\r\n        return;\r\n    }\r\n    if(currentNode.distance===Infinity) return;\r\n    if(currentNode.isVisited) return;\r\n    if(currentNode.isWall) return;\r\n    visitedNodes.push(currentNode);\r\n    currentNode.isVisited=true;\r\n    currentNode.previousNode=previous;\r\n    const{row,col}=currentNode;\r\n    if(row>0) {\r\n        const nextNode=grid[row-1][col];\r\n        nextNode.distance=currentNode.distance+1;\r\n        helper(visitedNodes,unVisitedNodes,grid,grid[row-1][col],finishNode,currentNode);\r\n    }\r\n    if(col<grid[0].length-1) {\r\n        const nextNode=grid[row][col+1];\r\n        nextNode.distance=currentNode.distance+1;\r\n        helper(visitedNodes,unVisitedNodes,grid,grid[row][col+1],finishNode,currentNode);\r\n    }\r\n    if(row<grid.length-1) {\r\n        const nextNode=grid[row+1][col];\r\n        nextNode.distance=currentNode.distance+1;\r\n        helper(visitedNodes,unVisitedNodes,grid,grid[row+1][col],finishNode,currentNode);\r\n    }\r\n    if(col>0) {\r\n        const nextNode=grid[row][col-1];\r\n        nextNode.distance=currentNode.distance+1;\r\n        helper(visitedNodes,unVisitedNodes,grid,grid[row][col-1],finishNode,currentNode);\r\n    }\r\n}\r\nconst getAllNode = (grid) => {\r\n    const unVisitedNodes=[];\r\n    for(const nodes of grid){\r\n        for(const node of nodes){\r\n            unVisitedNodes.push(node);\r\n        }\r\n    }\r\n    return unVisitedNodes;\r\n}\r\nexport const getShortestPath=(finishNode)=>{\r\n    let currentNode=finishNode;\r\n    const nodes=[];\r\n    while(currentNode!==null){\r\n        nodes.unshift(currentNode);\r\n        currentNode=currentNode.previousNode;\r\n    }\r\n    return nodes;\r\n}","export const astar=(grid,startNode,finishNode)=>{\r\n    const visitedNodes=[];\r\n    const unVisitedNodes=getAllNodes(grid);\r\n   // console.log(unVisitedNodes,finishNode);\r\n    calculateGFH(unVisitedNodes,finishNode); // this function will caculate f,g,h distance. f=total distance(g+h). h is heuristic distance from final node to current node. g is distance of starting to current\r\n    startNode.g=0;\r\n    startNode.f=startNode.g;\r\n    while(!!unVisitedNodes.length){\r\n        sortByDistance(unVisitedNodes);\r\n        const closestNode=unVisitedNodes.shift();\r\n        if(closestNode.isWall) continue;\r\n        if(closestNode.f===Infinity) return visitedNodes;\r\n        closestNode.isVisited=true;\r\n        visitedNodes.push(closestNode);\r\n        if(closestNode===finishNode) return visitedNodes;\r\n        updateNeighbours(grid,closestNode);     \r\n    }\r\n}\r\nconst updateNeighbours=(grid,closestNode)=>{\r\n    const neighbors=getAllNeighbors(grid,closestNode);\r\n    for(const neighbor of neighbors){\r\n        if(neighbor.g<closestNode.g+1) continue;\r\n        if(neighbor.isVisited) continue;\r\n        neighbor.g=closestNode.g+1;\r\n        neighbor.f=neighbor.h+neighbor.g;\r\n        neighbor.previousNode=closestNode;\r\n    }\r\n}\r\nconst getAllNeighbors=(grid,closestNode)=>{\r\n    const {row,col}=closestNode;\r\n    const neighbors=[];\r\n    if(row>0) neighbors.push(grid[row-1][col]);\r\n    if(row<grid.length-1) neighbors.push(grid[row+1][col]);\r\n    if(col>0) neighbors.push(grid[row][col-1]);\r\n    if(col<grid[0].length-1) neighbors.push(grid[row][col+1]);\r\n    return neighbors;\r\n}\r\nconst sortByDistance=(unVisitedNodes)=>{\r\n    unVisitedNodes.sort((nodeA,nodeB)=>nodeA.f-nodeB.f);\r\n}\r\nconst calculateGFH=(unVisitedNodes,finishNode)=>{\r\n    for(const node of unVisitedNodes){\r\n        node.f=Infinity;\r\n        node.g=Infinity;\r\n        node.h=heuristicManhattanDistance(node,finishNode);\r\n    }\r\n}\r\n\r\nconst heuristicManhattanDistance=(node,finishNode)=>{\r\n    return Math.abs(node.row-finishNode.row)+Math.abs(node.col-finishNode.col);\r\n}\r\nconst getAllNodes=(grid)=>{\r\n    const unvisitedNodes=[];\r\n    for(const row of grid){\r\n        for(const node of row){\r\n            unvisitedNodes.push(node);\r\n        }\r\n    }\r\n    return unvisitedNodes;\r\n}\r\nexport const getNodesInShortestPathAstar=(finishNode)=>{\r\n    let currentNode=finishNode;\r\n    const shortestPath=[];\r\n    while(currentNode!=null){\r\n        shortestPath.unshift(currentNode);\r\n        currentNode=currentNode.previousNode;\r\n    }\r\n    return shortestPath;\r\n}","const stackChild=[];\r\nexport const dfsMaze=(grid,startX,startY)=>{\r\n    const startNode=grid[startX][startY];\r\n    startNode.isVisited=true;\r\n    startNode.isWall=true;\r\n    const visitedNodes=[];\r\n    visitedNodes.push(startNode);\r\n    dfsMazeRecursive(grid,startX,startY,visitedNodes);\r\n    return visitedNodes;\r\n}\r\nconst dfsMazeRecursive=(grid,x,y,visitedNodes)=>{\r\n    const node=grid[x][y];\r\n    const array=[0,1,2,3];\r\n    for(let i=array.length-1;i>0;i--){\r\n        const j=Math.floor(Math.random()*(i-1));\r\n        [array[i],array[j]]=[array[j],array[i]];\r\n    }\r\n    //console.log(array);\r\n    const sideNodesX1=[0,0,1,-1];\r\n    const sideNodesY1=[1,-1,0,0];\r\n    const sideNodesX2=[0,0,2,-2];\r\n    const sideNodesY2=[2,-2,0,0];\r\n    for(let k=0;k<=3;k++){\r\n        const i=array[k];\r\n        const {col,row}=node;\r\n        const newX2=row+sideNodesX2[i];\r\n        const newY2=col+sideNodesY2[i];\r\n        if(!(newX2>=0 && newY2>=0 && newX2<grid.length && newY2<grid[0].length)) continue;\r\n        const neighbor=grid[newX2][newY2];\r\n        if(neighbor.isVisited===true || neighbor.isWall===true) continue;\r\n        const newX1=row+sideNodesX1[i];\r\n        const newY1=col+sideNodesY1[i];\r\n        if((newX2>=0 && newY2>=0 && newX2<grid.length && newY2<grid[0].length)){\r\n            grid[newX1][newY1].isWall=true;\r\n            grid[newX1][newY1].isVisited=true;\r\n            visitedNodes.push(grid[newX1][newY1]);\r\n        }\r\n        stackChild.push({'x':newX2,'y':newY2});\r\n        //stackChild.push({'x':newX1,'y':newY2});\r\n        const childNode=grid[newX2][newY2];\r\n        childNode.isVisited=true;\r\n        childNode.isWall=true;\r\n        visitedNodes.push(grid[newX2][newY2]);\r\n    }\r\n    while(stackChild.length!==0){\r\n        const node=stackChild.pop();\r\n        // console.log(stackChild);\r\n        // console.log(node);\r\n        dfsMazeRecursive(grid,node['x'],node['y'],visitedNodes);\r\n    }\r\n}","export const recursiveDivision=(grid)=>{\r\n    const visitedNodes=[];\r\n    const height=grid.length;\r\n    const width=grid[0].length;\r\n    //console.log(grid[height]);\r\n    for(let i=0;i<height;i++){\r\n        const tempNode=grid[i][0],tempNode1=grid[i][width-1];\r\n        tempNode.isWall=true;\r\n        tempNode1.isWall=true;\r\n        visitedNodes.push(tempNode);\r\n        visitedNodes.push(tempNode1);\r\n    }\r\n    for(let i=0;i<width;i++){\r\n        const tempNode=grid[0][i],tempNode1=grid[height-1][i];\r\n        tempNode.isWall=true;\r\n        tempNode1.isWall=true;\r\n        visitedNodes.push(tempNode);\r\n        visitedNodes.push(tempNode1);\r\n    }\r\n    recursiveDivisionMaze(grid,visitedNodes,1,height-2,1,width-2);\r\n    return visitedNodes;\r\n}\r\nfunction recursiveDivisionMaze(grid,visitedNodes,startX,endX,startY,endY){\r\n    const height=endX-startX+1;\r\n    const width=endY-startY+1;\r\n    if(height<3 || width<3){\r\n        return;\r\n    }\r\n    if (startX < 0 || startY < 0 || endX >= grid.length || endY >= grid[0].length || startX > endX || startY > endY)\r\n        return;\r\n\r\n    const hOrV=getOrientation(height,width);\r\n    if(hOrV==='Horizontal'){\r\n        const wallX=getRandomInt(startX+1,endX-1);\r\n        const skipY=getRandomInt(startY+1,endY-1);\r\n        //const skipY1=getRandomInt(startY,endY);\r\n        for(let wallY=startY;wallY<=endY;wallY++){\r\n            if(wallY===skipY ){\r\n                // const temp=grid[wallX][skipY];\r\n                // const {row,col}=temp;\r\n                // const newNode={\r\n                //     ...temp,\r\n                //     isPath:true,\r\n                // }\r\n                // grid[row][col]=newNode;\r\n                continue;\r\n            }\r\n            // if(grid[wallX-1][wallY].isPath || grid[wallX+1][wallY].isPath || grid[wallX][wallY-1].isPath || grid[wallX][wallY+1].isPath) continue;\r\n            const node=grid[wallX][wallY];\r\n            node.isWall=true;\r\n            visitedNodes.push(node);\r\n        }\r\n        recursiveDivisionMaze(grid,visitedNodes,startX,wallX-1,startY,endY);\r\n        recursiveDivisionMaze(grid,visitedNodes,wallX+1,endX,startY,endY);\r\n}\r\n    else if(hOrV==='Vertical'){\r\n        const wallY=getRandomInt(startY+1,endY-1);\r\n        const skipX=getRandomInt(startX+1,endX-1);\r\n        //const skipX1=getRandomInt(startX,endX);\r\n        for(let wallX=startX;wallX<=endX;wallX++){\r\n            if(wallX===skipX){\r\n                // const temp=grid[wallX][wallY];\r\n                // const{row,col}=temp;\r\n                // const newNode={\r\n                //     ...temp,\r\n                //     isPath:true,\r\n                // }\r\n                // grid[row][col]=newNode;\r\n                continue;\r\n            }\r\n            // if(grid[wallX][wallY-1].isPath || grid[wallX][wallY+1].isPath || grid[wallX-1][wallY].isPath || grid[wallX+1][wallY].isPath) continue;\r\n            //if(!grid[wallX+1][wallY].isWall) continue;\r\n            const node=grid[wallX][wallY];\r\n            node.isWall=true;\r\n            visitedNodes.push(node);\r\n        }\r\n        recursiveDivisionMaze(grid,visitedNodes,startX,endX,startY,wallY-1);\r\n        recursiveDivisionMaze(grid,visitedNodes,startX,endX,wallY+1,endY);\r\n    }\r\n}\r\nconst getRandomInt=(min,max)=>{\r\n    max = max + 1;\r\n    return Math.floor(Math.random() * (max - min)) + min;\r\n}\r\nfunction getOrientation(height,width){\r\n    if(height>width){\r\n        return \"Horizontal\";\r\n    }\r\n    else if(height<width){\r\n        return \"Vertical\";\r\n    }\r\n    else{\r\n        const i=(Math.random()*1);\r\n        if(i===1) return \"Vertical\";\r\n        else return \"Horizontal\";\r\n    }\r\n}","export const kruskal=(grid)=>{\r\n    const unVisitedNodes=getAllNodes(grid);\r\n    addNewProperty(unVisitedNodes);\r\n    const walls=[];\r\n    console.log(unVisitedNodes);\r\n    while(!!unVisitedNodes.length){\r\n        let idx=Math.floor(Math.random()*unVisitedNodes.length);\r\n        const currentNode=unVisitedNodes[idx];\r\n        currentNode.isNeighborVisited=true;\r\n        //console.log(currentNode);\r\n        const neighbors=getAllNeighbors(currentNode,grid);\r\n        const neighborNode=neighbors[Math.floor(Math.random()*neighbors.length)];\r\n        const neighborNode1=neighbors[Math.floor(Math.random()*neighbors.length)];\r\n        \r\n        if(!neighborNode.isNeighborVisited) neighborNode.isWall=true;\r\n        if(!neighborNode1.isNeighborVisited) neighborNode1.isWall=true;\r\n        currentNode.isWall=true;\r\n       \r\n        if(!neighborNode.isNeighborVisited) walls.push(neighborNode);\r\n        if(!neighborNode1.isNeighborVisited) walls.push(neighborNode1);\r\n        walls.push(currentNode);\r\n        \r\n        for(const neighbor of neighbors){\r\n            let tempIdx=unVisitedNodes.indexOf(neighbor);\r\n            neighbor.isNeighborVisited=true;\r\n            unVisitedNodes.splice(tempIdx,1);\r\n        }\r\n        unVisitedNodes.splice(idx,1);\r\n    }\r\n    console.log(unVisitedNodes);\r\n    return walls;\r\n}\r\nconst getAllNeighbors=(currentNode,grid)=>{\r\n    const neighbors=[];\r\n    const {row,col}=currentNode;\r\n    if(row>0) neighbors.push(grid[row-1][col]);\r\n    if(row<grid.length-1) neighbors.push(grid[row+1][col]);\r\n    if(col>0) neighbors.push(grid[row][col-1]);\r\n    if(col<grid[0].length-1) neighbors.push(grid[row][col+1]);\r\n    if(row>0 && col>0) neighbors.push(grid[row-1][col-1]);\r\n    if(row<grid.length-1 && col>0) neighbors.push(grid[row+1][col-1]);\r\n    if(row<grid.length-1 && col<grid[0].length-1) neighbors.push(grid[row+1][col+1]);\r\n    if(row>0 && col<grid[0].length-1) neighbors.push(grid[row-1][col+1]);\r\n    return neighbors;\r\n}\r\nconst addNewProperty=(unVisitedNodes)=>{\r\n    for(const node of unVisitedNodes){\r\n        node.isNeighborVisited=false\r\n    }\r\n}\r\nconst getAllNodes=(grid)=>{\r\n    const nodes=[];\r\n    for(const row of grid){\r\n        for(const node of row){\r\n            nodes.push(node);\r\n        }\r\n    }\r\n    return nodes;\r\n}","export const biBfs=(grid,startNode,finishNode)=>{\r\n    const visitedNodes1=[];\r\n    const visitedNodes2=[];\r\n    const visitedNodes=[];\r\n    const q1=[];\r\n    const q2=[];\r\n    startNode.distance=0;\r\n    finishNode.distance=0;\r\n    q1.push(startNode);\r\n    q2.push(finishNode);\r\n    while(!!q1.length && !!q2.length){\r\n        const fromStart=q1.shift();\r\n        const fromEnd=q2.shift();\r\n        if(fromStart.distance===Infinity || fromEnd.distance===Infinity) return visitedNodes;\r\n        if(!fromStart.isWall){\r\n            const neighbors=getAllNeighbors(grid,fromStart);\r\n            for(const neighbor of neighbors){\r\n                if(visitedNodes2.includes(neighbor)){\r\n                    //visitedNodes.push(neighbor);\r\n                    //midNodeFromStart=neighbor;\r\n                    visitedNodes.push(fromStart);\r\n                    fromStart.isVisited=true;\r\n                    neighbor.nextNode=fromStart;\r\n                    return [visitedNodes,neighbor,neighbor.nextNode];\r\n                }\r\n                if(neighbor.isVisited) continue;\r\n                neighbor.isVisited=true;\r\n                neighbor.previousNode=fromStart;\r\n                neighbor.distance=fromStart.distance+1;\r\n                q1.push(neighbor);\r\n            }\r\n            fromStart.isVisited=true;\r\n            visitedNodes1.push(fromStart);\r\n            visitedNodes.push(fromStart);\r\n        }\r\n        if(!fromEnd.isWall){\r\n            const neighbors=getAllNeighbors(grid,fromEnd);\r\n            for(const neighbor of neighbors){\r\n                if(visitedNodes1.includes(neighbor)){\r\n                   // visitedNodes.push(neighbor);\r\n                    visitedNodes.push(fromEnd);\r\n                    fromEnd.isVisited=true;\r\n                    neighbor.nextNode=fromEnd;\r\n                    return [visitedNodes,neighbor,neighbor.nextNode];\r\n                }\r\n                if(neighbor.isVisited) continue;\r\n                neighbor.isVisited=true;\r\n                neighbor.previousNode=fromEnd;\r\n                neighbor.distance=fromEnd.distance+1;\r\n                q2.push(neighbor);\r\n            }\r\n            fromEnd.isVisited=true;\r\n            visitedNodes2.push(fromEnd);\r\n            visitedNodes.push(fromEnd);\r\n        }\r\n        \r\n        if(visitedNodes1.includes(fromEnd) || visitedNodes2.includes(fromStart)){\r\n            return visitedNodes;\r\n        }\r\n    }\r\n    return [visitedNodes,null,null];\r\n}\r\n\r\nconst getAllNeighbors=(grid,node)=>{\r\n    const {row,col}=node;\r\n    const neighbors=[];\r\n    if(row>0) neighbors.push(grid[row-1][col]);\r\n    if(row<grid.length-1) neighbors.push(grid[row+1][col]);\r\n    if(col>0) neighbors.push(grid[row][col-1]);\r\n    if(col<grid[0].length-1) neighbors.push(grid[row][col+1]);\r\n    return neighbors;\r\n}\r\nexport const getNodesInShortestPathBiBfs=(midNodeFromStart,midNodeFromEnd)=>{\r\n    const nodesInShortestPath=[];\r\n    let currentNode=midNodeFromEnd;\r\n    while(currentNode!==null){\r\n        nodesInShortestPath.unshift(currentNode);\r\n        currentNode=currentNode.previousNode;\r\n    }\r\n    currentNode=midNodeFromStart;\r\n    while(currentNode!=null){\r\n        nodesInShortestPath.unshift(currentNode);\r\n        currentNode=currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPath;\r\n}","import React, { useState, useEffect } from \"react\";\r\nimport style from \"./Pathfinder.module.css\";\r\nimport Node from \"./Node\";\r\nimport cover from \"../icons/cover.png\"\r\nimport {\r\n  Button,\r\n  Select,\r\n  MenuItem,\r\n  InputLabel,\r\n  FormControl,\r\n  Typography,\r\n  ButtonGroup\r\n} from \"@material-ui/core\";\r\nimport {\r\n  dijsktra,\r\n  getNodesInShortestPathOrder,\r\n} from \"../Algorithms/Dijsktra\";\r\nimport { dfs, getShortestPath } from \"../Algorithms/DFS\";\r\nimport { bfs, getNodesInShortestPath } from \"../Algorithms/BFS\";\r\nimport { astar, getNodesInShortestPathAstar } from \"../Algorithms/Astar\";\r\nimport { dfsMaze } from \"../MazeAlgorithm/dfsmaze\";\r\nimport { recursiveDivision } from \"../MazeAlgorithm/RecursiveDivision\";\r\nimport { kruskal } from \"../MazeAlgorithm/kruskal\";\r\nimport { biBfs, getNodesInShortestPathBiBfs } from \"../Algorithms/BiBfs\";\r\n\r\nconst ROWS=window.innerHeight;\r\nconst COLS=window.innerWidth;\r\n\r\nconst PathFinder = () => {\r\n  const [grid, setGrid] = useState([]);\r\n  const [mouseIsPressed, setMousePress] = useState(false);\r\n  const [startNode, setStartNode] = useState(true);\r\n  const [endNode, setEndNode] = useState(false);\r\n  const [startRow, setStartRow] = useState(-1);\r\n  const [startCol, setStartCol] = useState(-1);\r\n  const [finishRow, setFinishRow] = useState(-1);\r\n  const [finishCol, setFinishCol] = useState(-1);\r\n  const [disableButtons,setDisableButtons]=useState({});\r\n  \r\n  useEffect(() => {\r\n    const newGrid = getIntialGrid();\r\n    setGrid(newGrid);\r\n    const disableButton={\r\n      visualise:false,\r\n      clearBoard:false,\r\n      previousBoard:false,\r\n      maze:false\r\n    }\r\n    setDisableButtons(disableButton);\r\n  }, []);\r\n  const createNode = (col, row) => {\r\n    return {\r\n      col,\r\n      row,\r\n      isStart: false,\r\n      isFinish: false,\r\n      distance: Infinity,\r\n      isVisited: false,\r\n      isWall: false,\r\n      previousNode: null,\r\n    };\r\n  };\r\n  const getIntialGrid = () => {\r\n    const newGrid = [];\r\n    for (let row = 0; row < Math.floor(ROWS/29); row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < Math.floor(COLS/25); col++) {\r\n        currentRow.push(createNode(col, row));\r\n      }\r\n      newGrid.push(currentRow);\r\n    }\r\n    //console.log(newGrid.length,newGrid[0].length);\r\n    return newGrid;\r\n  };\r\n  const findDijkstraPath = () => {\r\n    // console.log(startRow,startCol);\r\n    // console.log(finishRow,finishCol);\r\n    const startNode = grid[startRow][startCol];\r\n    const finishNode = grid[finishRow][finishCol];\r\n    // console.log(startNode,startNode);\r\n    // console.log(finishNode,finishNode);\r\n    const visitedNodes = dijsktra(grid, startNode, finishNode);\r\n    //console.log(visitedNodes);\r\n    // console.log(visitedNodes);\r\n    const nodesInShortestPath = getNodesInShortestPathOrder(finishNode);\r\n    animatePath(visitedNodes, nodesInShortestPath);\r\n    setTimeout(()=>{\r\n      const disableButton1={\r\n        ...disableButtons,\r\n        visualise:false,\r\n        clearBoard:false,\r\n        previousBoard:false,\r\n        maze:false\r\n      }\r\n      setDisableButtons(disableButton1);\r\n    },visitedNodes.length*10);\r\n  };\r\n  const findDfs = () => {\r\n    const startNode = grid[startRow][startCol];\r\n    const finishNode = grid[finishRow][finishCol];\r\n    const visitedNodes = dfs(grid, startNode, finishNode);\r\n    //console.log(visitedNodes);\r\n    const nodesInShortestPath = getShortestPath(finishNode);\r\n    animatePath(visitedNodes, nodesInShortestPath);\r\n    setTimeout(()=>{\r\n      const disableButton1={\r\n        ...disableButtons,\r\n        visualise:false,\r\n        clearBoard:false,\r\n        previousBoard:false,\r\n        maze:false\r\n      }\r\n      setDisableButtons(disableButton1);\r\n    },visitedNodes.length*10);\r\n  };\r\n  const findAstar = () => {\r\n    const startNode = grid[startRow][startCol];\r\n    const finishNode = grid[finishRow][finishCol];\r\n    //console.log(finishNode);\r\n    const visitedNodes = astar(grid, startNode, finishNode);\r\n    const nodesInShortestPath = getNodesInShortestPathAstar(finishNode);\r\n    animatePath(visitedNodes, nodesInShortestPath);\r\n    setTimeout(()=>{\r\n      const disableButton1={\r\n        ...disableButtons,\r\n        visualise:false,\r\n        clearBoard:false,\r\n        previousBoard:false,\r\n        maze:false\r\n      }\r\n      setDisableButtons(disableButton1);\r\n    },visitedNodes.length*10);\r\n  };\r\n\r\n  const findBfs = () => {\r\n    const startNode = grid[startRow][startCol];\r\n    const finishNode = grid[finishRow][finishCol];\r\n    const visitedNodes = bfs(grid, startNode, finishNode);\r\n    // console.log(visitedNodes);\r\n    const nodesInShortestPath = getNodesInShortestPath(finishNode);\r\n    console.log(visitedNodes);\r\n    //console.log(nodesInShortestPath);\r\n    // const nodesInShortestPath=[];\r\n    animatePath(visitedNodes, nodesInShortestPath);\r\n    setTimeout(()=>{\r\n      const disableButton1={\r\n        ...disableButtons,\r\n        visualise:false,\r\n        clearBoard:false,\r\n        previousBoard:false,\r\n        maze:false\r\n      }\r\n      setDisableButtons(disableButton1);\r\n    },visitedNodes.length*10);\r\n  };\r\n\r\n  const bidirectionalBFS = () => {\r\n    const startNode = grid[startRow][startCol];\r\n    const finishNode = grid[finishRow][finishCol];\r\n    const [visitedNodes, midFromStart, midFromEnd] = biBfs(\r\n      grid,\r\n      startNode,\r\n      finishNode\r\n    );\r\n    // console.log(visitedNodes);\r\n    const nodesInShortestPath = getNodesInShortestPathBiBfs(\r\n      midFromStart,\r\n      midFromEnd\r\n    );\r\n    animatePath(visitedNodes, nodesInShortestPath);\r\n    setTimeout(()=>{\r\n      const disableButton1={\r\n        ...disableButtons,\r\n        visualise:false,\r\n        clearBoard:false,\r\n        previousBoard:false,\r\n        maze:false\r\n      }\r\n      setDisableButtons(disableButton1);\r\n    },visitedNodes.length*10);\r\n  };\r\n  const dfsRecursiveMaze = () => {\r\n    const startX = Math.floor(Math.random() * grid.length);\r\n    const startY = Math.floor(Math.random() * grid[0].length);\r\n    //console.log(grid);\r\n    const walls = dfsMaze(grid, startX, startY);\r\n    //console.log(grid);\r\n    for (let i = 0; i < walls.length; i++) {\r\n      const { row, col } = walls[i];\r\n      setTimeout(() => {\r\n        document.getElementById(`node-${row}-${col}`).className =\r\n          \"node node-wall1\";\r\n      }, i * 10);\r\n    }\r\n    setTimeout(() => {\r\n      const newGrid = toggleVisitedAfterMaze(grid, walls);\r\n      setGrid(newGrid);\r\n    }, walls.length * 10);\r\n  };\r\n  const recursiveMaze = () => {\r\n    //console.log(grid);\r\n    //const walls=[];\r\n    const walls = recursiveDivision(grid);\r\n    for (let i = 0; i < walls.length; i++) {\r\n      setTimeout(() => {\r\n        const { row, col } = walls[i];\r\n        document.getElementById(`node-${row}-${col}`).className =\r\n          \"node node-wall1\";\r\n      }, i * 10);\r\n    }\r\n  };\r\n  const kruskalMaze = () => {\r\n    const walls = kruskal(grid);\r\n    //console.log(walls);\r\n    for (let i = 0; i < walls.length; i++) {\r\n      setTimeout(() => {\r\n        const { row, col } = walls[i];\r\n        document.getElementById(`node-${row}-${col}`).className =\r\n          \"node node-wall1\";\r\n      }, i * 10);\r\n    }\r\n  };\r\n  /*\r\n  Note: Timing in setTimeout is for individual node that after i*10 seconds we change the property of other node and so on.\r\n  As setTimeout is Ayscn function and it will not wait for current node to change color and it will move to next and then next\r\n  so after the specifeid time every node will change color suddenly.\r\n  */\r\n  const animatePath = (visitedNodes, nodesInShortestPath) => {\r\n    for (let i = 0; i <= visitedNodes.length; i++) {\r\n      if (i === visitedNodes.length) {\r\n        setTimeout(() => {\r\n          animateShortestPath(nodesInShortestPath);\r\n        }, 10 * i); //we are multiplyinng by i so that for ith node we wait i*10 seconds otherwise all animations will overlap\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodes[i];\r\n        if(!node.isStart && !node.isFinish)\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\"node node-visited\";\r\n        if(node.isStart)\r\n          document.getElementById(`node-${node.row}-${node.col}`).className=\"node node-start-visited\";\r\n        if(node.isFinish)\r\n          document.getElementById(`node-${node.row}-${node.col}`).className=\"node node-finish-visited\";\r\n      }, 10 * i);\r\n    }\r\n  };\r\n  const animateShortestPath = (nodesInShortestPath) => {\r\n    for (let i = 0; i < nodesInShortestPath.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPath[i];\r\n        if(!node.isStart && !node.isFinish)\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\"node node-shortest-path\";\r\n        if(node.isStart)\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-start-shortest-path\";\r\n        if(node.isFinish)\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-finish-shortest-path\";\r\n      }, 10 * i);\r\n    }\r\n  };\r\n  const setStartAndEndNode = (row, col) => {\r\n    if (startNode) {\r\n      const newGrid = getNewGridwithStartNode(grid, row, col);\r\n      setGrid(newGrid);\r\n      setStartRow(row);\r\n      setStartCol(col);\r\n      setEndNode(true);\r\n      setStartNode(false);\r\n    } else if (endNode) {\r\n      const newGrid = getNewGridWithEndNode(grid, row, col);\r\n      setGrid(newGrid);\r\n      setFinishRow(row);\r\n      setFinishCol(col);\r\n      setEndNode(false);\r\n    }\r\n  };\r\n  function handleMouseDown(row, col) {\r\n    // console.log(\"HandleMouseDowm\");\r\n    if (startNode || endNode) return;\r\n    const newGrid = getNewGridWithWall(grid, row, col);\r\n    setGrid(newGrid);\r\n    setMousePress(true);\r\n  }\r\n  function handleMouseEnter(row, col) {\r\n    //console.log(\"HandleMouseEnter\");\r\n    if (startNode || endNode) return;\r\n    if (!mouseIsPressed) return;\r\n    const newGrid = getNewGridWithWall(grid, row, col);\r\n    setGrid(newGrid);\r\n  }\r\n  function onMouseUp() {\r\n    if (startNode || endNode) return;\r\n    //console.log(\"HandleMouseUp\");\r\n    setMousePress(false);\r\n  }\r\n  const clearBoard = () => {\r\n    //console.log(\"Caled\");\r\n    setMousePress(false);\r\n    setStartNode(true);\r\n    setEndNode(false);\r\n    setStartRow(-1);\r\n    setStartCol(-1);\r\n    setFinishRow(-1);\r\n    setFinishCol(-1);\r\n    const newGrid = [];\r\n    for(let i=0;i<Math.floor(ROWS/29);i++){\r\n      const currentRow=[];\r\n      for(let j=0;j<Math.floor(COLS/25);j++){\r\n        currentRow.push(createNode(j,i));\r\n      }\r\n      newGrid.push(currentRow);\r\n    }\r\n    setGrid(newGrid)\r\n    for (const row of newGrid) {\r\n      for (const node of row) {\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\"node\";\r\n      }\r\n    }\r\n  };\r\n  const getPreviousBoard = () => {\r\n    const newGrid=[];\r\n    for(let row=0;row<Math.floor(ROWS/29);row++){\r\n      const currentRow=[];\r\n      for(let col=0;col<Math.floor(COLS/25);col++){\r\n        const newNode={\r\n          col,\r\n          row,\r\n          isStart:row===startRow&& col===startCol,\r\n          isFinish:row===finishRow && col===finishCol,\r\n          previousNode:null,\r\n          distance:Infinity,\r\n          isVisited:false,\r\n          isWall:false,\r\n        }\r\n        currentRow.push(newNode);\r\n      }\r\n      newGrid.push(currentRow);\r\n    }\r\n    for (const row of newGrid) {\r\n      for (const node of row) {\r\n        if (!node.isStart && !node.isFinish)\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node\";\r\n        if (!node.isStart && !node.isFinish)\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node\";\r\n        if (node.isStart)\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-start\";\r\n        if (node.isFinish)\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-finish\";\r\n      }\r\n    }\r\n    setGrid(newGrid);\r\n  };\r\n  const visualizeAlgorithm = () => {\r\n    if (algorithm === \"A* Search\") {\r\n      const disableButton={\r\n        ...disableButtons,\r\n        visualise:true,\r\n        clearBoard:true,\r\n        previousBoard:true,\r\n        maze:true\r\n      }\r\n      setDisableButtons(disableButton);\r\n      findAstar();\r\n    } else if (algorithm === \"Dijkstra Search\") {\r\n      const disableButton={\r\n        ...disableButtons,\r\n        visualise:true,\r\n        clearBoard:true,\r\n        previousBoard:true,\r\n        maze:true\r\n      }\r\n      setDisableButtons(disableButton);\r\n      findDijkstraPath();\r\n    } else if (algorithm === \"Bi-directional BFS\") {\r\n      const disableButton={\r\n        ...disableButtons,\r\n        visualise:true,\r\n        clearBoard:true,\r\n        previousBoard:true,\r\n        maze:true\r\n      }\r\n      setDisableButtons(disableButton);\r\n      bidirectionalBFS();\r\n    } else if (algorithm === \"Breadth First Search\") {\r\n      const disableButton={\r\n        ...disableButtons,\r\n        visualise:true,\r\n        clearBoard:true,\r\n        previousBoard:true,\r\n        maze:true\r\n      }\r\n      setDisableButtons(disableButton);\r\n      findBfs();\r\n    } else if (algorithm === \"Depth First Search\") {\r\n      const disableButton={\r\n        ...disableButtons,\r\n        visualise:true,\r\n        clearBoard:true,\r\n        previousBoard:true,\r\n        maze:true\r\n      }\r\n      setDisableButtons(disableButton);\r\n      findDfs();\r\n    } else{\r\n      alert(\"Choose an Alogrithm First\");\r\n    }\r\n  };\r\n  const visualizeMaze = () => {\r\n    if (maze === \"Recursive Division Maze\") {\r\n      recursiveMaze();\r\n    } else if (maze === \"DFS Recursive Maze\") {\r\n      dfsRecursiveMaze();\r\n    } else if (maze === \"Random Walls\") {\r\n      kruskalMaze();\r\n    } else{\r\n      alert(\"Choose Maze Algorithm First\")\r\n    }\r\n  };\r\n  const [algorithm, setAlgorithm] = useState(\"\");\r\n  const [maze, setMaze] = useState(\"\");\r\n  return (\r\n    <div className={style.container}>\r\n      <div className={style.nav}>\r\n        <img src={cover} alt=\"Missing\" width=\"50px\" height=\"40px\" className={style.image}></img>\r\n        <FormControl variant={COLS<20?\"filled\":\"outlined\"} centered className={style.formControl}>\r\n          <InputLabel id=\"alogrithm-selector\">\r\n            <Typography style={{fontFamily: \"'Kodchasan', sans-serif\"}} className={style.labelText} align=\"center\" display=\"inline\">\r\n              Choose Pathfinding Algorithm\r\n            </Typography>\r\n          </InputLabel>\r\n          <Select\r\n            value={algorithm}\r\n            onChange={(e) => setAlgorithm(e.target.value)}\r\n            labelId=\"algorithm-selector\"\r\n          >\r\n            <MenuItem value={\"A* Search\"}>\r\n              <Typography color=\"secondary\">A* Search</Typography>\r\n            </MenuItem>\r\n            <MenuItem value={\"Dijkstra Search\"}>\r\n              <Typography color=\"secondary\">Dijkstra Search</Typography>\r\n            </MenuItem>\r\n            <MenuItem value={\"Bi-directional BFS\"}>\r\n              <Typography color=\"secondary\">Bi-directional BFS</Typography>\r\n            </MenuItem>\r\n            <MenuItem value={\"Breadth First Search\"}>\r\n              <Typography color=\"secondary\">Breadth First Search</Typography>\r\n            </MenuItem>\r\n            <MenuItem value={\"Depth First Search\"}>\r\n              <Typography color=\"secondary\">Depth First Search</Typography>\r\n            </MenuItem>\r\n          </Select>\r\n        </FormControl>\r\n        <div className=\"button-group\">\r\n        <Button\r\n          color=\"secondary\"\r\n          variant=\"outlined\"\r\n          onClick={() => visualizeAlgorithm()}\r\n          className={style.button}\r\n          disabled={disableButtons.visualise}\r\n        >\r\n          <Typography variant=\"body2\" className={style.buttonText}>\r\n            Visualise {algorithm}\r\n          </Typography>\r\n        </Button>\r\n        <Button\r\n          color=\"secondary\"\r\n          variant=\"outlined\"\r\n          onClick={() => getPreviousBoard()}\r\n          className={style.button}\r\n          disabled={disableButtons.previousBoard}\r\n        >\r\n          <Typography variant=\"body2\" className={style.buttonText}>\r\n            Previous Board\r\n          </Typography>\r\n        </Button>\r\n        <Button\r\n          color=\"secondary\"\r\n          variant=\"outlined\"\r\n          onClick={() => clearBoard()}\r\n          className={style.button}\r\n          disabled={disableButtons.clearBoard}\r\n        >\r\n          <Typography variant=\"body2\" className={style.buttonText}>\r\n            Clear Board\r\n          </Typography>\r\n        </Button>\r\n        <Button\r\n          color=\"secondary\"\r\n          variant=\"outlined\"\r\n          onClick={() => visualizeMaze()}\r\n          className={style.button}\r\n          disabled={disableButtons.maze}\r\n        >\r\n          <Typography variant=\"body2\" className={style.buttonText}>\r\n            Visualise Maze\r\n          </Typography>\r\n        </Button>\r\n        </div>\r\n        <FormControl variant={COLS<20?\"filled\":\"outlined\"} className={style.formControl}>\r\n          <InputLabel id=\"maze-selector\">\r\n            <Typography align=\"center\" className={style.labelText} style={{fontFamily: \"'Kodchasan', sans-serif\"}}>\r\n              Generate Mazes\r\n            </Typography>\r\n          </InputLabel>\r\n          <Select\r\n            value={maze}\r\n            onChange={(e) => setMaze(e.target.value)}\r\n            labelId=\"maze-selector\"\r\n          >\r\n            <MenuItem value={\"Recursive Division Maze\"}>\r\n              <Typography color=\"secondary\">Recusive Divison Maze</Typography>\r\n            </MenuItem>\r\n            <MenuItem value={\"DFS Recursive Maze\"}>\r\n              <Typography color=\"secondary\">DFS Recurive Maze</Typography>\r\n            </MenuItem>\r\n            <MenuItem value={\"Random Walls\"}>\r\n              <Typography color=\"secondary\">Random Walls</Typography>\r\n            </MenuItem>\r\n          </Select>\r\n        </FormControl>\r\n      </div>\r\n      <div id=\"grid\" className={style.grid}>\r\n        {grid.map((row, rowIdx) => {\r\n          return (\r\n            <div key={rowIdx}>\r\n              {row.map((node, nodeIdx) => {\r\n                return (\r\n                  <Node\r\n                    key={nodeIdx}\r\n                    isStart={node.isStart}\r\n                    isFinish={node.isFinish}\r\n                    isVisited={node.isVisited}\r\n                    isWall={node.isWall}\r\n                    row={node.row}\r\n                    col={node.col}\r\n                    onMouseClick={(row, col) => setStartAndEndNode(row, col)}\r\n                    onMouseUp={() => onMouseUp()}\r\n                    onMouseDown={(row, col) => handleMouseDown(row, col)}\r\n                    onMouseEnter={(row, col) => handleMouseEnter(row, col)}\r\n                  ></Node>\r\n                );\r\n              })}\r\n            </div>\r\n          );\r\n        })}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\nconst toggleVisitedAfterMaze = (grid, walls) => {\r\n  const newGrid = grid.slice();\r\n  for (let i = 0; i < walls.length; i++) {\r\n    const { row, col } = walls[i];\r\n    const node = walls[i];\r\n    const newNode = {\r\n      ...node,\r\n      isVisited: false,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n  }\r\n  return newGrid;\r\n};\r\nconst getNewGridwithStartNode = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: false,\r\n    isStart: true,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\nconst getNewGridWithEndNode = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: false,\r\n    isFinish: true,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\nconst getNewGridWithWall = (grid, row, col) => {\r\n  //console.log(\"Calledd\");\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\nexport default PathFinder;\r\n","export const bfs=(grid,startNode,finishNode)=>{\r\n    const visitedNodes=[];\r\n    //const unVisitedNodes=getAllNodes(grid);\r\n    let queue=[];\r\n    startNode.distance=0;\r\n    queue.push(startNode);\r\n    //console.log(startNode);\r\n    while(!!queue.length){\r\n        let currentNode=queue.shift();\r\n        if(currentNode.isWall) continue; \r\n        if(currentNode.distance===Infinity) {\r\n        //     console.log('infi');\r\n            return visitedNodes;\r\n         }\r\n        if(currentNode===finishNode){ \r\n            visitedNodes.push(currentNode);\r\n            return visitedNodes;\r\n        }\r\n        visitedNodes.push(currentNode);\r\n        currentNode.isVisited=true;\r\n        const {row,col} = currentNode;\r\n        \r\n        if(row>0){\r\n            let nextNode=grid[row-1][col];\r\n            if(!nextNode.isVisited && !queue.includes(nextNode))\r\n            {\r\n                nextNode.distance=currentNode.distance+1;\r\n                nextNode.previousNode=currentNode;\r\n                queue.push(nextNode);\r\n            }\r\n        }\r\n        if(col>0){\r\n            let nextNode=grid[row][col-1];\r\n            if(!nextNode.isVisited && !queue.includes(nextNode))\r\n           {\r\n                nextNode.distance=currentNode.distance+1;\r\n                nextNode.previousNode=currentNode;\r\n                queue.push(nextNode);\r\n            }\r\n        }\r\n        if(row<grid.length-1){\r\n            let nextNode=grid[row+1][col];\r\n            if(!nextNode.isVisited && !queue.includes(nextNode))\r\n           {\r\n                nextNode.distance=currentNode.distance+1;\r\n                nextNode.previousNode=currentNode;\r\n                queue.push(nextNode);\r\n            }\r\n        }\r\n        if(col<grid[0].length-1){\r\n            let nextNode=grid[row][col+1];\r\n            if(!nextNode.isVisited && !queue.includes(nextNode))\r\n            {\r\n                nextNode.distance=currentNode.distance+1;\r\n                nextNode.previousNode=currentNode;\r\n                queue.push(nextNode);\r\n            }\r\n        }\r\n    }\r\n    return visitedNodes;\r\n}\r\nexport const getNodesInShortestPath=(finishNode)=>{\r\n    let currentNode=finishNode;\r\n    let shortestPathNodes=[];\r\n    while(currentNode!=null){\r\n        shortestPathNodes.unshift(currentNode);\r\n        currentNode=currentNode.previousNode;\r\n    }\r\n    return shortestPathNodes;\r\n}\r\n","import React from 'react';\r\nimport './App.css';\r\nimport PopUp from './PathFinder/PopUp.jsx';\r\nimport './bootstrap/dist/css/bootstrap.min.css'\r\nimport PathFinder from './PathFinder/Pathfinder'\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n       <PopUp/>\r\n      <PathFinder/> \r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}